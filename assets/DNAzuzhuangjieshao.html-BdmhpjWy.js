import { _ as _export_sfc, r as resolveComponent, c as createElementBlock, a as createBaseVNode, b as createStaticVNode, d as createTextVNode, e as createVNode, o as openBlock } from "./app-wHNjQSIG.js";
const _sfc_main = {};
const _hoisted_1 = ["src"];
const _hoisted_2 = ["src"];
const _hoisted_3 = {
  href: "http://www.nature.com/nmeth/journal/v4/n3/abs/nmeth1010.html",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_4 = ["src"];
const _hoisted_5 = {
  href: "http://www.nature.com/nmeth/journal/v4/n3/abs/nmeth1010.html",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_6 = {
  href: "https://www.nature.com/nmeth/journal/v6/n5/abs/nmeth.1318.html",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_7 = ["src"];
const _hoisted_8 = {
  href: "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0006441",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_9 = ["src"];
const _hoisted_10 = {
  href: "http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3333860/",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_11 = ["src"];
const _hoisted_12 = ["src"];
const _hoisted_13 = {
  href: "http://www.ncbi.nlm.nih.gov/pubmed/21107654",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_14 = {
  href: "http://www.ncbi.nlm.nih.gov/pubmed/21293463",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_15 = {
  href: "http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0003647",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_16 = {
  href: "http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0005553",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_17 = {
  href: "http://www.ncbi.nlm.nih.gov/pubmed/21365490",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_18 = ["src"];
const _hoisted_19 = {
  href: "https://www.neb.com/",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_20 = {
  href: "http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0003647",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_21 = {
  href: "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0005553",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_22 = {
  href: "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0016765",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_23 = {
  href: "http://www.ncbi.nlm.nih.gov/pubmed/22126803",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_24 = ["src"];
const _hoisted_25 = {
  href: "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0016765",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_26 = {
  href: "https://doi.org/10.1021/sb500366v",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_27 = ["src"];
const _hoisted_28 = ["src"];
function _sfc_render(_ctx, _cache) {
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return openBlock(), createElementBlock("div", null, [
    _cache[57] || (_cache[57] = createBaseVNode("h1", {
      id: "dna组装介绍",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#dna组装介绍"
      }, [
        createBaseVNode("span", null, "DNA组装介绍")
      ])
    ], -1)),
    _cache[58] || (_cache[58] = createBaseVNode("p", null, "装置设计没有使用传统的多克隆位点、连接酶克隆方法去设计DNA组装，为了更好理解为什么不，有必要回顾一下传统组装方法，并将其与目前大多数合成生物学家经常使用的方法进行对比。", -1)),
    _cache[59] || (_cache[59] = createBaseVNode("h2", {
      id: "传统多克隆位点组装",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#传统多克隆位点组装"
      }, [
        createBaseVNode("span", null, "传统多克隆位点组装")
      ])
    ], -1)),
    _cache[60] || (_cache[60] = createBaseVNode("p", null, "下图所示是一个基于传统方法设计组装质粒的典型案例：", -1)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-1-MCS.png"),
      alt: "DNA组装介绍-1-MCS"
    }, null, 8, _hoisted_1),
    _cache[61] || (_cache[61] = createStaticVNode('<p>在此案例中，一个多克隆位点（multiple cloning site, MCS）两边分别跟随一个T7启动子和T7终止子。如果研究人员想将一个感兴趣的蛋白质编码序列整合到这个表达载体，实现步骤如下：</p><ul><li>1）从MCS中挑选两个限制性酶切位点，同时编码序列中不存在这两个酶切位点；</li><li>2）设计一对引物，引物对5&#39;侧分别带有上述所选两个酶切位点，通过PCR扩增编码序列；</li><li>3）用所选的酶分别消化编码序列的PCR产物以及目标载体；</li><li>4）凝胶纯化消化后的PCR产物和目标载体；</li><li>5）连接纯化后的PCR产物和目标载体；</li><li>6）将连接产物转化到感受态的大肠杆菌中。</li></ul><p>该方法对单基因插入目标载体的设计很适用，因为大量的MCS中（本案例中有11个）大概率能找到两个在编码序列中不存在的酶切位点。然而，一旦想要将多个DNA序列连接到同一个表达载体时（如构建一个代谢途径）找到合适酶切位点的概率将大大减小。分子生物学家探索出了各种策略来解决该常见的阻碍，如：</p><ul><li>1）在DNA序列中引入点突变以破坏酶切位点；</li><li>2）使用PCR扩增的方式将两条或多条DNA序列连接在一起；</li><li>3）在各DNA序列两端引入互相兼容的单链悬垂（overhangs），这些单链悬垂需满足在退火形成双链DNA序列后不会出现酶切识别位点；</li><li>4）使用DNA oligo/RecA复合物来保护特定的甲基化敏感酶位点；</li><li>5）最后按顺序依次组装各DNA序列，这样同一个限制性酶切位点可能被多次使用（但这也使下游克隆和复用变得困难）</li><li>......</li></ul><p>在此想明确指出的是，直接合成DNA，虽然在某些情况下不是目前最便宜的选择，但却是一个非常可行的替代DNA组装的策略，并且有能力规避很多组装障碍。在装置设计中，我们也支持直接合成DNA的策略。</p><p>SLIC/Gibson/CPEC/SLiCE和Golden-gate中大多数组装方法是衍生于上述传统的多克隆位点，这些方法与传统方法的不同之处在于“标准化”。在传统的克隆中，所选择的限制性内切酶集（以及希望通过点突变破坏的酶切位点）完全依赖于要组装的片段的序列、数量和顺序。因此，每一个不同的组装都可能需要不同的限制性内切酶、点突变、反应温度和缓冲条件的组合。此外，同一条感兴趣的DNA序列在不同的组装中需要进行完全重新的克隆，限制了片段在不同组装中的重用性。虽然限制酶公司（如NEB和Thermo）在保证所有限制性内切酶都能在单一反应条件（温度、缓冲液等）下运行方面取得了很大进展，但一般来说，一个酶催化的反应混合液不太可能应用于独立的传统组装，使得传统组装方法不易于实现平行化、自动化的高通量组装设计。相比之下，SLIC/Gibson/CPEC/SLiCE和Golden-gate对每个组装都是用相同的（标准化）酶和反应条件。当需要点突变的时候每个组装都需要相同的突变，因此每个序列片段只需要克隆一次，便于重复利用。因此，这些标准化的方法比传统方法更易于平行化、自动化的高通量组装。</p><h2 id="dna组装挑战" tabindex="-1"><a class="header-anchor" href="#dna组装挑战"><span>DNA组装挑战</span></a></h2><p>简单地说，DNA组装的挑战是将一组双链DNA序列按照适当的顺序、方向连接在一起，形成一个单一的、可能是环形的组装DNA序列。在合成生物学中，这些DNA组装片段通常被称为“parts”（元件），特殊情况下这些片段可能是某种特定生物学功能相关的元件，如启动子、编码序列、终止子等，就装置设计软件而言，各元件指广义的DNA序列。</p><p>以下是一个DNA组装的一个实际案例：</p>', 9)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-2-8piecesExample.png"),
      alt: "DNA组装介绍-2-8piecesExample"
    }, null, 8, _hoisted_2),
    _cache[62] || (_cache[62] = createBaseVNode("p", null, "该示例是将8个非重复的生物元件：1个载体，5个具有上游核糖体结合位点的蛋白编码序列，1个终止子和1个启动子。值得注意的是，在此案例中启动子和终止子被使用了两次来实现目标表达载体。", -1)),
    _cache[63] || (_cache[63] = createBaseVNode("h2", {
      id: "slic-gibson-cpec-slice组装",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#slic-gibson-cpec-slice组装"
      }, [
        createBaseVNode("span", null, "SLIC/Gibson/CPEC/SLiCE组装")
      ])
    ], -1)),
    _cache[64] || (_cache[64] = createBaseVNode("p", null, "SLIC, Gibson, CPEC和SLiCE是有关联性的组装方式，都能实现标准化的、无痕的、非序列相关的多元件组装。因为这几项组装方法的输入序列和输出序列都是一样的，装置设计将这几类组装均归为一类。下面将分别简单介绍各组装方法的特点和不足。", -1)),
    _cache[65] || (_cache[65] = createBaseVNode("h3", {
      id: "slic",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#slic"
      }, [
        createBaseVNode("span", null, "SLIC")
      ])
    ], -1)),
    createBaseVNode("p", null, [
      _cache[1] || (_cache[1] = createTextVNode("SLIC（Sequence and Ligation independent cloning）（")),
      createBaseVNode("a", _hoisted_3, [
        _cache[0] || (_cache[0] = createTextVNode("Li 2007")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[2] || (_cache[2] = createTextVNode("），如其名字，它不使用限制性酶和连接酶，是一种一次能组装多个片段的组装方法。SLIC的思路是在目标片段上构造overlap，并使得overlap形成互补的粘末端。"))
    ]),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-3-SLIC.png"),
      alt: "DNA组装介绍-3-SLIC"
    }, null, 8, _hoisted_4),
    _cache[66] || (_cache[66] = createBaseVNode("p", null, [
      createTextVNode("用SLIC方法将元件"),
      createBaseVNode("em", null, "partA"),
      createTextVNode("与一个线性目标载体组装在一起的主要步骤包括：")
    ], -1)),
    createBaseVNode("ul", null, [
      _cache[6] || (_cache[6] = createBaseVNode("li", null, [
        createBaseVNode("p", null, "1）通过PCR或者限制性酶切将载体线性化；设计组装片段的PCR引物，使得DNA片段拥有相邻片段的端部同源序列（约25bp）；")
      ], -1)),
      _cache[7] || (_cache[7] = createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          createTextVNode("2）在没有dNTPs的情况下，利用T4 DNA聚合酶的3'端外切活性使线性载体和"),
          createBaseVNode("em", null, "partA"),
          createTextVNode("的PCR产物产生5' overhangs（该过程被称为“chew-back”），overhangs的长度由反应时间粗略控制；")
        ])
      ], -1)),
      createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          _cache[4] || (_cache[4] = createTextVNode("3）一旦上一步产生足够长的5'互补单链overhangs，加入dCTP来阻止T4 DNA聚合酶的外切活性。随着dCTP的加入，T4 DNA聚合酶的活性从3'外切酶改变为聚合酶，但因为不是所有的dNTPs都存在，大部分chew-back后的缺口都被保留。替代T4 DNA聚合酶的3'端外切活性的方案是使用混合或不完整的PCR产品，但这种方法不适用与通过限制酶切的线性化载体，而是适用于PCR产生的线性载体（")),
          createBaseVNode("a", _hoisted_5, [
            _cache[3] || (_cache[3] = createTextVNode("Li 2007")),
            createVNode(_component_ExternalLinkIcon)
          ]),
          _cache[5] || (_cache[5] = createTextVNode("）；"))
        ])
      ]),
      _cache[8] || (_cache[8] = createBaseVNode("li", null, [
        createBaseVNode("p", null, "4）退火，粘末端互补。由于在反应体系中没有连接酶，这导致一个质粒有四个单链缺口。一旦转化到感受态大肠杆菌，这些间隙就会被修复。")
      ], -1))
    ]),
    _cache[67] || (_cache[67] = createBaseVNode("p", null, "SLIC组装技术是标准化的，因为它总是使用相同的反应组分和条件。SLIC技术也是无疤痕的，因为组装结果中没有不是用户设计的序列，而且是序列无关的，因为该方法对目标载体或要嵌入的元件的序列不敏感。", -1)),
    _cache[68] || (_cache[68] = createBaseVNode("h3", {
      id: "gibson",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#gibson"
      }, [
        createBaseVNode("span", null, "Gibson")
      ])
    ], -1)),
    createBaseVNode("p", null, [
      _cache[10] || (_cache[10] = createTextVNode("Gibson组装（")),
      createBaseVNode("a", _hoisted_6, [
        _cache[9] || (_cache[9] = createTextVNode("Gibson 2009")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[11] || (_cache[11] = createTextVNode("）的基本思想与SLIC无异，也是一种利用overlap的拼接策略。其改进之处在于将外切、聚合、连接集中于一个反应之中。"))
    ]),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-4-Gibson.png"),
      alt: "DNA组装介绍-4-Gibson"
    }, null, 8, _hoisted_7),
    _cache[69] || (_cache[69] = createStaticVNode('<p>用Gibson方法将元件<em>partA</em>与一个线性目标载体组装在一起的主要步骤包括：</p><ul><li><p>1）同上：设计引物、扩增片段；</p></li><li><p>2）将线性化目的载体和含有partA的PCR产物与T5外切酶混合在一起，T5 外切酶活会从5&#39;到3&#39;消化线性化目的载体和PCR产物产生3&#39;末端overhangs；</p></li><li><p>3）退火，粘末端互补。外切酶逐渐热失活，Phusion聚合酶作用快于外切酶活性，最终追及形成nick，由Taq连接酶填补缺口。</p></li></ul><p>与SLIC相似，Gibson组装是标准化、无疤痕且与序列无关的。Gibson比SLIC更有优势的原因是它是一个一步反应（不需要分两步添加dCTP），连接酶的存在可以提高组装效率，而且由于Gibson组装反应发生在较SLIC相对高些的温度下，所以组装片段末端出现二级结构的现象会减少。</p><p>缺点：Gibson方法的缺点是T5外切酶、Phusion聚合酶和Taq连接酶混合物比SLIC所需的更昂贵。Gibson方法的经验限制是，它最适合组装至少250 bp或更长的DNA片段。这可能是因为T5外切酶在有机会使Phusion聚合酶引导扩展之前，会完全咀嚼短的DNA片段。虽然对于SLIC也可以这样说，但是dCTP添加的时间控制可以在T4 DNA聚合酶的外切酶活性和聚合酶活性之间切换（使用混合或不完整的PCR产物可以完全避免这个问题），但是在使用SLIC组装小的DNA片段时应谨慎。在进行Gibson（或SLIC）组装之前，建议将相邻的组装片段进行SOE（重叠扩增）拼接，直到它们的累积大小大于250 bp。幸运的是，为Gibson（和SLIC）组装设计的同样的PCR产物已经包含了所需的侧翼同源序列。</p><h3 id="cpec" tabindex="-1"><a class="header-anchor" href="#cpec"><span>CPEC</span></a></h3>', 5)),
    createBaseVNode("p", null, [
      _cache[13] || (_cache[13] = createTextVNode("CPEC (Circular Polymerase Extension Cloning, ")),
      createBaseVNode("a", _hoisted_8, [
        _cache[12] || (_cache[12] = createTextVNode("Quan 2009")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[14] || (_cache[14] = createTextVNode(")，过程类似于SOE(Splicing by Overlap Extension)将要组装的片段拼接在一起，但不使用寡核苷酸（线性化的目标载体和PCR产物相互引导扩增，类似于SLIC/Gibson组装），通常只需要几个热循环。"))
    ]),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-5-CPEC.png"),
      alt: "DNA组装介绍-5-CPEC"
    }, null, 8, _hoisted_9),
    _cache[70] || (_cache[70] = createStaticVNode('<p>用CPEC方法将元件<em>partA</em>与一个线性目标载体组装在一起的主要步骤包括：</p><ul><li><p>1）同上：设计引物、扩增片段；</p></li><li><p>2）将组装片段的扩增产物混合，并进行热变性处理，使DNA双链解开；</p></li><li><p>3）热变形退火：通过温度梯度的方式进行热变性退火，使两个扩增产物的重叠区域互相结合；</p></li><li><p>4）扩增连接：在热变性退火的条件下，序列间互为模板和引物在DNA聚合酶的作用下延伸为含有缺口的环状DNA分子，该缺口可在大肠杆菌中得到修复从而得到完整的质粒。</p></li></ul><p>与SLIC和Gibson组装类似，CPEC是标准化的、无疤痕的，并且在很大程度上不依赖于序列。CPEC的优势在于，由于没有外切酶的作用，小的序列片段可以直接组装而无需预先进行SOEing步骤，没有dNTP添加步骤（不像SLIC），只需要一个酶（聚合酶）（不像Gibson），并且由于CPEC组装反应发生在比SLIC或Gibson更高的温度下，组装片段末端的稳定二级结构相对较少引起关注。CPEC的主要缺点是它更容易产生聚合酶引起的突变，而不像SLIC或Gibson，错引事件现在可能发生在要组装的片段的任何位置（而不仅仅是在片段的末端），尽管根据T5外切酶的起步位置，Gibson方法可能会遇到类似的问题。</p><h3 id="slice" tabindex="-1"><a class="header-anchor" href="#slice"><span>SLiCE</span></a></h3>', 4)),
    createBaseVNode("p", null, [
      _cache[16] || (_cache[16] = createTextVNode("SLiCE (Seamless Ligation Cloning Extract, ")),
      createBaseVNode("a", _hoisted_10, [
        _cache[15] || (_cache[15] = createTextVNode("Zhang 2012")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[17] || (_cache[17] = createTextVNode(") 使用与SLIC、Gibson和CPEC（如上所述）相同类型的DNA起始材料，并产生相同的最终产物。然而，与SLIC、Gibson或CPEC不同，SLiCE利用细菌细胞提取物（即体外DNA组装方法），因为实验室细菌菌株可以用作SLiCE提取物的来源，因此非常经济高效。"))
    ]),
    _cache[71] || (_cache[71] = createBaseVNode("h3", {
      id: "slic-gibson-cpec-slice的相似之处",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#slic-gibson-cpec-slice的相似之处"
      }, [
        createBaseVNode("span", null, "SLIC/Gibson/CPEC/SLiCE的相似之处")
      ])
    ], -1)),
    _cache[72] || (_cache[72] = createBaseVNode("p", null, "尽管它们在实施上存在差异，SLIC、Gibson、CPEC和SLiCE组装方法都以相同的起始材料开始，并产生相同的最终产品：", -1)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-6-similarity.png"),
      alt: "DNA组装介绍-6-similarity"
    }, null, 8, _hoisted_11),
    _cache[73] || (_cache[73] = createBaseVNode("p", null, "回到最初的多片段组装挑战，下面是我们如何使用SLIC/Gibson/CPEC/SLiCE组装方法来组装这条代谢途径：", -1)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-2-8piecesExample-solution.png"),
      alt: "DNA组装介绍-2-8piecesExample-solution"
    }, null, 8, _hoisted_12),
    _cache[74] || (_cache[74] = createBaseVNode("p", null, "在这个例子中，每个同源区域都用了不同颜色进行着色。需要注意的是，与BioBrick组装不同，使用SLIC/Gibson/CPEC/SLiCE，我们可以同时在同一个容器中组装多个元件（多元件组装）。与hierarchical binary BioBrick组装相比，多元件组装中可以立即获得要组装的每个元件，并且只需一步转化，就可以捕获组合产物的多样性。如案例所示，尽管在构建过程中我们没有使用BioBrick组装，我们可以使用SLIC/Gibson/CPEC/SLiCE组装方法生成一个无痕的BioBrick（BglBrick）载体。SLIC/Gibson/CPEC/SLiCE组装的缺点是我们现在必须为每个组装连接点专门设计5'侧同源寡核苷酸序列，这个过程可能会繁琐、费时且容易出错。", -1)),
    _cache[75] || (_cache[75] = createBaseVNode("h3", {
      id: "slic-gibson-cpec-slice的限制和阻碍",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#slic-gibson-cpec-slice的限制和阻碍"
      }, [
        createBaseVNode("span", null, "SLIC/Gibson/CPEC/SLiCE的限制和阻碍")
      ])
    ], -1)),
    _cache[76] || (_cache[76] = createBaseVNode("p", null, "SLIC/Gibson/CPEC/SLiCE组装的限制在于：", -1)),
    createBaseVNode("ul", null, [
      _cache[23] || (_cache[23] = createBaseVNode("li", null, [
        createBaseVNode("p", null, "1）组装片段两端可能会自互连形成发卡、茎环等二级结构（可能会发生在终止子序列区），从而阻断邻近组装片段的退火连接。在某种程度上，可以将这些问题端部序列填充到相邻组装片段上来环节这种情况。")
      ], -1)),
      _cache[24] || (_cache[24] = createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          createTextVNode("2）由于组装时由序列同源性引导的，如果两个不同组装片段端部序列一样（如上述案例中3'端的终止子），这可能导致组装产物中缺少组装片段或者组装片段排血错误。为了克服此种困难，装置设计组装算法"),
          createBaseVNode("code", null, "在今后的版本中"),
          createTextVNode("将执行一个分层组装，以避免同一组装反应中同时放置具有相同末端的组装片段。"),
          createBaseVNode("code", null, "（#TODO）"),
          createTextVNode("我们建议用户在可能情况下，最好用不同的序列替换重复序列，这不仅对DNA组装过程有好处，而且还将增强结果结构的DNA稳定性。")
        ])
      ], -1)),
      createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          _cache[20] || (_cache[20] = createTextVNode("3）在组合元件库构建的组装设计中，如果序列多样性发生在组装片段的末端15bp左右时，由于无法在每个片段组合中重复使用相同的同源序列，SLIC/Gibson/CPEC/SLiCE组装可能不是最好的选择。但在特定的某些情况下（如")),
          createBaseVNode("a", _hoisted_13, [
            _cache[18] || (_cache[18] = createTextVNode("Ramon 2010")),
            createVNode(_component_ExternalLinkIcon)
          ]),
          _cache[21] || (_cache[21] = createTextVNode(" 的Gibson组装案例和")),
          createBaseVNode("a", _hoisted_14, [
            _cache[19] || (_cache[19] = createTextVNode("Quan 2011")),
            createVNode(_component_ExternalLinkIcon)
          ]),
          _cache[22] || (_cache[22] = createTextVNode(" 的CPEC组装案例），每个组装片段在所有的组合可能下都一致，组合性SLIC/Gibson/CPEC/SLiCE组装将是非常有效的解决方案。"))
        ])
      ])
    ]),
    _cache[77] || (_cache[77] = createBaseVNode("p", null, "这些特殊情况，在某种程度上也说明SLIC/Gibson/CPEC/SLiCE组装方法并非完全与序列无关，而这些限制，在很大程度上能被Golden Gate组装方法解决。", -1)),
    _cache[78] || (_cache[78] = createBaseVNode("h2", {
      id: "golden-gate组装",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#golden-gate组装"
      }, [
        createBaseVNode("span", null, "Golden Gate组装")
      ])
    ], -1)),
    createBaseVNode("p", null, [
      _cache[28] || (_cache[28] = createTextVNode("Golden Gate及其衍生组装方法（")),
      createBaseVNode("a", _hoisted_15, [
        _cache[25] || (_cache[25] = createTextVNode("Engler 2008")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[29] || (_cache[29] = createTextVNode(", ")),
      createBaseVNode("a", _hoisted_16, [
        _cache[26] || (_cache[26] = createTextVNode("Engler 2009")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[30] || (_cache[30] = createTextVNode(", ")),
      createBaseVNode("a", _hoisted_17, [
        _cache[27] || (_cache[27] = createTextVNode("Engler 2011")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[31] || (_cache[31] = createTextVNode("）提供了标准化、准无疤痕的多元件组装，是组合文库构建的不错选择。"))
    ]),
    _cache[79] || (_cache[79] = createBaseVNode("p", null, "该方法是一种新型的酶切连接方法，与传统的酶切连接不同。传统的酶切连接方法采用标准的TypeII型限制性内切酶（例如EcoRI）切割DNA，这些限制酶通常识别4~8bp的回文序列，并在识别序列内部切割产生粘性末端或平末端。而Golden Gate是采用TypeIIs型限制酶（例如BsaI）切割DNA，这些酶是在识别序列以外剪切产生四个碱基的粘性末端。由于粘性末端不是识别序列的一部分，因此它们可以直接作为连接DNA的片段。在设计无误的情况下，识别位点不会出现在最终的质粒中，达到精确的无缝克隆，连接效率接近100%。此外，四个碱基的特异性末端能用来连接多个片段，从而在一个反应体系中实现多片段的克隆重组。", -1)),
    _cache[80] || (_cache[80] = createBaseVNode("h3", {
      id: "从pcr产物开始的单层golden-gate组装",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#从pcr产物开始的单层golden-gate组装"
      }, [
        createBaseVNode("span", null, "从PCR产物开始的单层Golden Gate组装")
      ])
    ], -1)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-7-GoldenGate.png"),
      alt: "DNA组装介绍-7-GoldenGate"
    }, null, 8, _hoisted_18),
    _cache[81] || (_cache[81] = createStaticVNode("<p>上图案例中我们用<code>BsaI</code> TypeIIs酶，其识别位点<code>GGTCTC</code>不具回文性，切割方向特定。在上图组装示意图中，在dsDNA序列线下方用白色矩形框代表酶切识别位点，并用黑色箭头表示酶切割方向，箭头所指方向的在dsDNA线上的彩色矩形表示酶切后4bp的黏末端位置。</p><p>Golden Gate方法将元件<em>partA</em>与一个线性目标载体组装在一起的主要步骤包括：</p><ul><li><p>1）设计引物扩增目的片段：通过PCR向先行载体及组装片段中引入<code>BsaI</code>识别序列，为了确保限制酶能稳定结合到DNA双链上并发挥切割作用，需在识别序列末端加上保护碱基。如上图所示，<em>partA</em>的扩增产物两端各有一个<code>BsaI</code>识别位点，切割位点互相指向<em>partA</em>内测，在下一步酶切反应中形成红色和蓝色的4bp overhang。线性载体的PCR产物的示意图也类似。</p></li><li><p>2）酶切连接：将PCR产物（线性载体和目标片段）与<code>BsaI</code>和连接酶混合，被酶消化后的片段（都带有红色和蓝色4bp overhang的片段）将在连接酶的作用下进行无缝连接。由于目标产物中已不含<code>BsaI</code>识别位点，因此这种连接是不可逆的。</p></li></ul><p>值得指出的是，蓝色和红色4bp overhang完全由用户指定，可以是原本就存在于序列上的，而不是额外引入的序列，因此此类Golden Gate也是无痕的。同时也有需要注意的事项：</p>", 4)),
    createBaseVNode("ul", null, [
      _cache[37] || (_cache[37] = createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          createTextVNode("1）"),
          createBaseVNode("strong", null, "DNA片段之间连接的粘性末端序列设计"),
          createTextVNode("：要避免使用回文性的overhang，否则他们将自互补；任何两种（如图中红色和蓝色）overhang序列至少有1~2bp不一样，以保证不同的overhang之间不能互补从而保证多序列之间能按理想的顺序连接。")
        ])
      ], -1)),
      createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          _cache[33] || (_cache[33] = createTextVNode("2）")),
          _cache[34] || (_cache[34] = createBaseVNode("strong", null, "选择合适的缓冲液", -1)),
          _cache[35] || (_cache[35] = createTextVNode("：因为内切酶和连接酶同时存在于同一反应体系，所以缓冲液的选择尤为重要。在限制性核酸内切酶4种NEBuffer中，T4 DNA连接酶都具有有效活性（")),
          createBaseVNode("a", _hoisted_19, [
            _cache[32] || (_cache[32] = createTextVNode("NEB")),
            createVNode(_component_ExternalLinkIcon)
          ]),
          _cache[36] || (_cache[36] = createTextVNode("）。因此能够推断，多数情况下反应体系可以考虑首选限制性内切酶的缓冲液。"))
        ])
      ]),
      _cache[38] || (_cache[38] = createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          createTextVNode("3）"),
          createBaseVNode("strong", null, "事先观察载体和目标片段的酶切位点"),
          createTextVNode("：为了避免不必要的消化，对于目的载体而言，如果采用与Golden Gate反应阶段相同的酶来进行线性化，则需保证载体上有且仅存在两个相应的酶切位点。若通过PCR来制备线性化载体，则同其他组装片段一样，需保证所有片段（载体、组装片段）中不能出现将要使用的TypeIIs酶切位点。如果因为情况特殊出现的话，目的片段的剪切要换用其它的TypeIIs型限制酶，并且需要确保酶切后的粘性末端可以与载体进行组装，实验时需要对载体和目的片段分别进行酶切后再进行连接。")
        ])
      ], -1)),
      _cache[39] || (_cache[39] = createBaseVNode("li", null, [
        createBaseVNode("p", null, [
          createTextVNode("4）"),
          createBaseVNode("strong", null, "控制反应体系中目的片段及载体浓度"),
          createTextVNode("：在酶切含量一定的情况下，若目的片段及载体的浓度过高，可能会造成不完全酶切。")
        ])
      ], -1))
    ]),
    _cache[82] || (_cache[82] = createBaseVNode("h3", {
      id: "从未切割的序列开始的多层级golden-gate组装",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#从未切割的序列开始的多层级golden-gate组装"
      }, [
        createBaseVNode("span", null, "从未切割的序列开始的多层级Golden Gate组装")
      ])
    ], -1)),
    createBaseVNode("p", null, [
      _cache[44] || (_cache[44] = createTextVNode("在")),
      createBaseVNode("a", _hoisted_20, [
        _cache[40] || (_cache[40] = createTextVNode("Engler 2008")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[45] || (_cache[45] = createTextVNode(", ")),
      createBaseVNode("a", _hoisted_21, [
        _cache[41] || (_cache[41] = createTextVNode("Engler 2009")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[46] || (_cache[46] = createTextVNode(", ")),
      _cache[47] || (_cache[47] = createBaseVNode("a", { href: "www.ncbi.nlm.nih.gov/pubmed/21365490" }, "Engler 2011", -1)),
      _cache[48] || (_cache[48] = createTextVNode("等提出的Golden Gate方法之后，")),
      createBaseVNode("a", _hoisted_22, [
        _cache[42] || (_cache[42] = createTextVNode("Weber 2011")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[49] || (_cache[49] = createTextVNode(", ")),
      createBaseVNode("a", _hoisted_23, [
        _cache[43] || (_cache[43] = createTextVNode("Werner 2012")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[50] || (_cache[50] = createTextVNode("等相继提出了MoClo（模块化克隆技术）方法，它采用Backbone Module（是各种环形目标载体骨架，不同载体具有不同限制性内切酶切割位点，酶切线性化后根据产生的特定的overhang可以与特定的相同酶消化后的Cassette Module或TU结合）与Cassette Module（是用户自定义的各种DNA功能片段，可以酶切消化后嵌入到特定的Backbone Module中，以实现多基因表达）相互组合的方式构建多基因构建，实现了高效、可靠和可重复的DNA组装。未切割的质粒作为原材料的提议好处在于更容易控制组装计量，因为每个质粒都经过序列验证而无需使用PCR，限制在于载体以及所有组装元件必须已经克隆到一个Golden Gate形式的质粒系统中，并且为了保证在后续Golden Gate反应中片段按照正确的顺序连接，未切割组装载体的酶切overhangs都需已确定。为了避免不正确的组装，装置设计会检查原始组装序列中不含有额外的酶切位点。"))
    ]),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-8-MoClo.png"),
      alt: "DNA组装介绍-8-MoClo"
    }, null, 8, _hoisted_24),
    _cache[83] || (_cache[83] = createStaticVNode("<p>用MoClo方法实现多基因构建的主要步骤包括：</p><ul><li><p>1）<strong>准备所需DNA片段：</strong> 购买或合成所需的DNA片段，并设计带有<code>BpiI</code>的引物，使不同Cassette Module的扩增产物<code>BpiI</code>酶切后产生不同的overhangs（P(GGAG, TACT), U(TACT,AATG), SP(AATG, AGGT), CDS(AGGT, GCTT), T(GCTT, CGCT)），以便在后续Golden Gate反应中不同组件进行组装；</p></li><li><p>2）<strong>Level 0 Module构建：</strong> 上述不同类DNA的PCR产物与不同的Level 0 backbone（Level 0 backbone上的<em>LacZ</em>区域两端分别有一对<code>BpiI</code>和<code>BsaI</code>酶切位点，<code>BpiI</code>在<code>BsaI</code>的5&#39;远端，两个酶切位点产生同样的4-bp黏末端。根据酶切产生的黏末端种类，不同的DNA片段将与不同的backbone反应），在T4 DNA连接酶和<code>BpiI</code>反应体系中反应，分别生成一系列Level 0产物（pL0-P, pL0-U, pL0-S, pL0-C, pL0-T）；Level 0环形载体中，插入的DNA序列两端还留下一对<code>BsaI</code>酶切位点，用以下一轮Golden Gate反应；</p></li><li><p>3）<strong>Level 1 Module构建：</strong> 上述Level 0的环形载体产物与Level 1 backbone（Level 1 backbone上的<em>LacZ</em>区域两端分别有一对<code>BsaI</code>和<code>BpiI</code>酶切位点，<code>BsaI</code>在<code>BpiI</code>的5&#39;远端，两个酶切位点产生同样的4-bp黏末端），在T4 DNA连接酶和<code>BsaI</code>反应体系中反应，生成Level 1产物TU1、TU2、TUX (TU, Transcription Unit)；Level 1环形载体中，TUX两端还留下一对<code>BpiI</code>酶切位点，用以下一轮Golden Gate反应；</p></li><li><p>4）<strong>Level 2 Construct构建：</strong> 上述多个TUX产物与Level 2 backbone（Level 2 backbone上的<em>CRed</em>区域两端仅有一对<code>BpiI</code>酶切位点）在T4 DNA连接酶和<code>BpiI</code>反应体系中反应生成最终多基因产物。</p></li></ul>", 2)),
    createBaseVNode("p", null, [
      _cache[52] || (_cache[52] = createTextVNode("在")),
      createBaseVNode("a", _hoisted_25, [
        _cache[51] || (_cache[51] = createTextVNode("Weber 2011")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[53] || (_cache[53] = createTextVNode("中，研究人员用MoClo系统构建了三个多基因构建实例来验证其性能。第一个包括5个基因，第二个包括10个基因，并在酵母上进行表达；第三个是人类乳腺癌代谢路径的11个基因构建，并在人类乳腺癌细胞上进行表达。这些实验表明MoClo系统可以快速且有效地构建复杂的多基因构建，而无需设计专门的引物和克隆步骤。同时，由于采用模块化的方式组装DNA，MoClo系统具有标准化、可重复和易用的优点，具有广泛应用的潜力。尽管MoClo系统已被证明在多种生物中都能实现多基因结构的组装，但其效果可能会受到不同生物间序列差异的影响。自动化MoClo构建过程的资源开销大，需要较高前端基础设施和软件支持。同时，相应的技术人员需要经过一定的培训才能熟练操作该系统。"))
    ]),
    _cache[84] || (_cache[84] = createBaseVNode("h3", {
      id: "从pcr开始设计的多层级golden-gate组装设计",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#从pcr开始设计的多层级golden-gate组装设计"
      }, [
        createBaseVNode("span", null, "从PCR开始设计的多层级Golden Gate组装设计")
      ])
    ], -1)),
    createBaseVNode("p", null, [
      _cache[55] || (_cache[55] = createTextVNode("类似上一种组装方式，此类组装也属于MoClo（模块化克隆技术）方法，只不过需要先通过PCR给各类型元件引入酶切位点开始。在")),
      createBaseVNode("a", _hoisted_26, [
        _cache[54] || (_cache[54] = createTextVNode("Michael 2015")),
        createVNode(_component_ExternalLinkIcon)
      ]),
      _cache[56] || (_cache[56] = createTextVNode("中介绍了定义酵母装配标准的重要性以及如何通过标准化来实现基因组装的高效性和可靠性。研究人员提出了一种统一的组装标准，以确保不同实验室在进行基因组、代谢途径或功能组装时使用相同的装配标准。该标准规定了一组基本装配规则，包括固定的引物设计、基因序列的克隆技术、碎片大小、装配顺序等等。通过这种标准化的方法，可以为酵母研究提供更多的可重复性和可比性。同时，这种标准化的方法也可以加速基因组装的速度和降低成本，提高酵母蛋白质工程的效率。"))
    ]),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-9-YTK-1.png"),
      alt: "DNA组装介绍-9-YTK-1"
    }, null, 8, _hoisted_27),
    _cache[85] || (_cache[85] = createStaticVNode('<p>如上图(1)所示酵母表达中组装DNA的标准是自下而上的分级DNA构建，研究人员将在酵母菌中组装复杂质粒以表达多个基因的工作流程抽象为多个层级：</p><ul><li><p>1）<strong>准备所需DNA片段：</strong> 首先，如上图(3)所示通过PCR或直接合成向不同类型元件（如上图(2)所示编号为1-8）中引入<code>BsmBI</code>和<code>BsaI</code>两个酶切位点，其中<code>BsmBI</code>在<code>BsaI</code>的5&#39;远端。不同元件引入一对相同的<code>BsmBI</code>酶切黏末端（TCGG、GCAA），而引入的一对<code>BsaI</code>酶切黏末端则根据元件的类型而定；</p></li><li><p>2）<strong>Level 0 Module的构建：</strong> 上述不同类型元件的PCR产物与同一个<code>Entry Vector</code>在T4 DNA连接酶和<code>BsmBI</code>反应体系同反应，分别生成一系列Level 0 产物（在该篇文献中也被称为Part Plasmid）。在这篇文献中，在part plasmid构建过程中，需特别注意编号1和5的元件，作为<em><strong>Connector</strong></em>元件，其序列内部有一个<code>BsmBI</code>位点用来在更高层级的golden gate多基因组装步骤起作用。这一阶段的质粒在大肠杆菌通常具有氯霉素耐药性。</p></li><li><p>3）<strong>Level 1 Module的构建：</strong> 上述各类part plasmid具有独特的上下游<code>BsaI</code>酶切黏末端，因此相同编号的part plasmid是可以互换的，通过<code>BsaI</code> Golden Gate反应形成Level 1产物（在该篇文献中也被称为Cassette Plasmid，或Transcriptional Unit）。这一阶段的质粒在大肠杆菌通常具有氨苄西林耐药性。</p></li><li><p>4）<strong>Level 2 Module的构建：</strong> 上述各类cassette plasmid可以通过<code>BsmBI</code>进一步组装生成Multigene Plasmid，产物中包含多个TU模块，TU之间顺序由单个cassette plasmid上5&#39;及3&#39;两端的Connector类型决定。这一阶段的质粒在大肠杆菌中通常具有卡那霉素耐药性。</p></li></ul><h3 id="golden-gate的限制和阻碍" tabindex="-1"><a class="header-anchor" href="#golden-gate的限制和阻碍"><span>Golden Gate的限制和阻碍</span></a></h3><ul><li><p>1）<strong>组装准确性:</strong> Golden Gate组装准确性很大程度上依赖于互相兼容的限制性内切识别位点，一旦组装片段过多，要找到合适的酶切黏末端是比较困难的。</p></li><li><p>2）<strong>序列同源性:</strong> 使用Golden Gate构建涉及具有高度序列同源性的部件的组装体是困难的。</p></li><li><p>3）<strong>载体大小</strong>：使用 Golden Gate 技术组装的 DNA 长度受所用质粒载体大小的限制。</p></li><li><p>4）<strong>共享克隆位点：</strong> 当多个部件具有共享的克隆位点时，可能会导致 Golden Gate 基于组装的效率降低。</p></li><li><p>6）<strong>长序列组装面临的困难：</strong> 在使用 Golden Gate 技术进行 DNA 拼接时，当需要进行的克隆步骤越多，比如需要拼接的 DNA 片段长度较长时，组装 DNA 序列会变得更加具有挑战性。</p></li><li><p>7）<strong>Type IIS酶的限制：</strong> Golden Gate利用了Type IIS内切酶的特殊切割方法，这些酶能够在其识别位置之外完成切割，因此可以用于连接不同序列的DNA片段。然而，这种酶的活性与周围的序列环境密切相关，并且这种环境因操作条件和基因组背景而异。这意味着在实验中需要注意到这种情况，并选择适当的酶来获得最佳结果。</p></li></ul><h2 id="突变组装" tabindex="-1"><a class="header-anchor" href="#突变组装"><span>突变组装</span></a></h2><p>基因多点突变是指在基因序列的不同位置引入多个突变的过程。这可以通过诸如定点突变技术等技术来实现，该技术允许研究人员对目标基因的DNA序列进行精确的改变。多点突变可用于改变基因的功能或表达，或创建原基因中不存在的新功能。这种方法常用于开发用于生物技术或医药的新蛋白质。实现基因多位点突变是一种体外（<em>in vitro</em>）操作过程，利用定制的寡核苷酸引物在双链DNA质粒中引入所需的变异。在设计引物之前，确定所需使用的变异工作流程非常重要。在装置设计中，我们提出了一种四步流程的多位点突变组装的流程：</p>', 6)),
    createBaseVNode("img", {
      src: _ctx.$withBase("/device-design/images/DNA组装介绍-10-MutationDesign.png"),
      alt: "DNA组装介绍-10-MutationDesign"
    }, null, 8, _hoisted_28),
    _cache[86] || (_cache[86] = createStaticVNode("<ul><li><p>1）<strong>序列片段化：</strong> 根据用户定义的突变坐标（DNA序列中单个待突变密码子的第一个碱基坐标）将序列片段化。一般在突变位点下游Nbp（用户可自定义，默认40bp）的区间内寻找合适的切割位置。因为后续我们将采用Golden Gate的组装工艺将片段化突变后序列组装成突变后产物，“合适的切割位置”是指切割后的片段之间能找到一组互相兼容的overhangs以实现无痕Golden Gate组装。找到合适的片段化位点后，需设计带有<code>BsmBI</code>和<code>BsaI</code>的引物（其中<code>BsmBI</code>在<code>BsaI</code>的5&#39;远端），然后通过PCR扩增得到原始DNA序列的4个子片段，每个片段两端携带一对<code>BsmBI</code>和<code>BsaI</code>位点。</p></li><li><p>2）<strong>将目标基因片段分别插入Level 0载体：</strong> 4个子片段分别与Level 0 backbone（Bb_1，Level 0 backbone上的<em>ccdb</em>区域两端有一对<code>BsmBI</code>酶切位点）在T4 DNA连接酶和<code>BsmBI</code>反应体系中反应，生成分别携带了4个子片段的环状Level 0产物。Level 0产物中，子片段两端保留了一对<code>BsaI</code>酶切位点，且<code>BsaI</code>酶切后产生互相兼容的overhangs用以在步骤4的Golden Gate反应中连接各子片段形成目标突变产物。</p></li><li><p>3）<strong>对各Lv0片段载体设计突变引物：</strong> 对上述每个Level 0产物设计两对PCR扩增引物，其中Forward1上携带目标突变碱基，与Reverse1一起扩增出突变区域，Forward2和Reverse2一起扩增出另一半正常区域。两对引物扩增的产物之间彼此带有临近片段的overlap，通过Gibson反应产生一系列携带目标突变位点的Level 0突变库。</p></li><li><p>4）<strong>将各Lv0突变载体组装得到目标突变载体：</strong> 从上述四个子片段的Level 0突变库中各选取一个突变产物与Level 1 backbone（Bb_2，Level 1 backbone上的<em>ccdb</em>区域两端有一对<code>BsaI</code>酶切位点）在T4 DNA连接酶和<code>BsaI</code>反应体系中反应，生成最终的Level 1状突变产物。通过排列组合以生成Level 1突变库。</p></li></ul>", 1))
  ]);
}
const DNAzuzhuangjieshao_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "DNAzuzhuangjieshao.html.vue"]]);
const data = JSON.parse('{"path":"/docs/device-design/more/DNAzuzhuangjieshao.html","title":"DNA组装介绍","lang":"en-US","frontmatter":{"title":"DNA组装介绍","date":"2025/05/22"},"headers":[{"level":2,"title":"传统多克隆位点组装","slug":"传统多克隆位点组装","link":"#传统多克隆位点组装","children":[]},{"level":2,"title":"DNA组装挑战","slug":"dna组装挑战","link":"#dna组装挑战","children":[]},{"level":2,"title":"SLIC/Gibson/CPEC/SLiCE组装","slug":"slic-gibson-cpec-slice组装","link":"#slic-gibson-cpec-slice组装","children":[{"level":3,"title":"SLIC","slug":"slic","link":"#slic","children":[]},{"level":3,"title":"Gibson","slug":"gibson","link":"#gibson","children":[]},{"level":3,"title":"CPEC","slug":"cpec","link":"#cpec","children":[]},{"level":3,"title":"SLiCE","slug":"slice","link":"#slice","children":[]},{"level":3,"title":"SLIC/Gibson/CPEC/SLiCE的相似之处","slug":"slic-gibson-cpec-slice的相似之处","link":"#slic-gibson-cpec-slice的相似之处","children":[]},{"level":3,"title":"SLIC/Gibson/CPEC/SLiCE的限制和阻碍","slug":"slic-gibson-cpec-slice的限制和阻碍","link":"#slic-gibson-cpec-slice的限制和阻碍","children":[]}]},{"level":2,"title":"Golden Gate组装","slug":"golden-gate组装","link":"#golden-gate组装","children":[{"level":3,"title":"从PCR产物开始的单层Golden Gate组装","slug":"从pcr产物开始的单层golden-gate组装","link":"#从pcr产物开始的单层golden-gate组装","children":[]},{"level":3,"title":"从未切割的序列开始的多层级Golden Gate组装","slug":"从未切割的序列开始的多层级golden-gate组装","link":"#从未切割的序列开始的多层级golden-gate组装","children":[]},{"level":3,"title":"从PCR开始设计的多层级Golden Gate组装设计","slug":"从pcr开始设计的多层级golden-gate组装设计","link":"#从pcr开始设计的多层级golden-gate组装设计","children":[]},{"level":3,"title":"Golden Gate的限制和阻碍","slug":"golden-gate的限制和阻碍","link":"#golden-gate的限制和阻碍","children":[]}]},{"level":2,"title":"突变组装","slug":"突变组装","link":"#突变组装","children":[]}],"git":{"createdTime":1748332588000,"updatedTime":1748332588000,"contributors":[{"name":"lld","email":"ld.ling@siat.ac.cn","commits":1}]},"filePathRelative":"docs/device-design/more/DNA组装介绍.md"}');
export {
  DNAzuzhuangjieshao_html as comp,
  data
};
